<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ù…ØµÙ†Ø¹ Ø§Ù„Ø±ÙˆØ¨ÙˆØª: ØªØ­Ø¯ÙŠ 8 Ø£Ø¬Ø²Ø§Ø¡</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Cairo Font for Arabic (Main Font) -->
    <link href="https://fonts.googleapis.com/css2?family=Cairo:wght@400;700;900&display=swap" rel="stylesheet">
    <!-- Tone.js for Sound Effects -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        body {
            font-family: 'Cairo', sans-serif;
            background-color: #f0f4f8; /* Light background */
        }
        /* New class for the requested font style (Times New Roman or a serif fallback) */
        .font-serif-math {
            font-family: "Times New Roman", Times, serif;
            /* Note: Times New Roman is a system font, relying on the user's device for availability. */
        }
        .shape-draggable {
            cursor: grab;
            transition: transform 0.2s, opacity 0.2s, background-color 0.3s;
            text-align: center;
            padding: 2px; /* Reduced padding slightly */
            font-size: 0.75rem; /* Reduced font size from 0.875rem (sm) to 0.75rem (xs) */
            line-height: 1.1; /* Adjusted line height for tight fit */
            pointer-events: none; /* Default to locked */
            opacity: 0.5;
            display: flex; /* Ensure centering works well */
            align-items: center;
            justify-content: center;
        }
        .shape-draggable.unlocked {
            cursor: grab;
            opacity: 1;
            pointer-events: auto; /* Allow dragging */
            box-shadow: 0 0 15px rgba(59, 130, 246, 0.5); /* Blue glow when unlocked */
        }
        .shape-draggable:active {
            cursor: grabbing;
        }
        .robot-part {
            position: absolute;
            background-color: #d1d5db; /* Default light gray for target */
            border: 3px dashed #6b7280;
            transition: background-color 0.4s, border-color 0.4s, box-shadow 0.4s;
            font-size: 0.875rem; /* Ensure target label is readable (text-sm) */
        }
        .robot-part.drag-over {
            border-color: #4f46e5;
            background-color: #e0e7ff;
        }
        .robot-part.assembled {
            border-style: solid;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        }
        .shape-container {
            display: flex;
            flex-wrap: wrap; 
            gap: 8px; 
            align-items: center;
            justify-content: center;
            border-radius: 0.75rem;
            min-height: 10rem; /* Increased height for 8 shapes */
        }
        /* Custom styles for shapes sizes */
        .shape-square { width: 80px; height: 80px; }
        .shape-rect-lg { width: 140px; height: 200px; }
        .shape-rect-arm { width: 30px; height: 100px; }
        .shape-rect-leg { width: 40px; height: 120px; }
        .shape-rect-foot { width: 60px; height: 20px; }

        /* The Robot Assembly Area - Taller to fit legs/feet */
        #robot-assembly {
            position: relative;
            width: 300px;
            height: 600px; 
            margin: 0 auto;
        }

        /* Positions for Robot Parts (Target areas) */
        #target-body { top: 100px; left: 80px; }
        #target-head { top: 20px; left: 110px; }
        #target-arm-l { top: 130px; left: 50px; transform-origin: top left; transform: rotate(-30deg); }
        #target-arm-r { top: 130px; right: 50px; transform-origin: top right; transform: rotate(30deg); }
        #target-leg-l { top: 300px; left: 100px; }
        #target-leg-r { top: 300px; left: 160px; }
        #target-foot-l { top: 425px; left: 90px; }
        #target-foot-r { top: 425px; left: 150px; }
        
        /* Animation for correct answer */
        @keyframes pulse-green {
            0% { box-shadow: 0 0 0 0 rgba(16, 185, 129, 0.7); }
            70% { box-shadow: 0 0 0 15px rgba(16, 185, 129, 0); }
            100% { box-shadow: 0 0 0 0 rgba(16, 185, 129, 0); }
        }
        .correct-pulse {
            animation: pulse-green 1s ease-out;
        }
        
        .question-card {
            background-color: #ffffff;
            border-radius: 12px;
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.1);
            padding: 2rem;
            border: 4px solid #3b82f6; /* Blue border */
            min-height: 300px;
        }
    </style>
</head>
<body class="p-4 md:p-8" onclick="startAudioContext()">

    <script>
        // --- Game State and Constants ---
        const SHAPES_DATA = {
            'head': { type: 'square', color: '#f59e0b', label: 'Ø§Ù„Ø±Ø£Ø³ (Ù…Ø±Ø¨Ø¹)', targetId: 'target-head' },
            'body': { type: 'rectangle', color: '#4f46e5', label: 'Ø§Ù„Ø¬Ø³Ù… (Ù…Ø³ØªØ·ÙŠÙ„)', targetId: 'target-body' },
            'arm-l': { type: 'rectangle-small', color: '#10b981', label: 'Ø§Ù„Ø°Ø±Ø§Ø¹ Ø§Ù„Ø£ÙŠØ³Ø± (Ù…Ø³ØªØ·ÙŠÙ„)', targetId: 'target-arm-l' },
            'arm-r': { type: 'rectangle-small', color: '#10b981', label: 'Ø§Ù„Ø°Ø±Ø§Ø¹ Ø§Ù„Ø£ÙŠÙ…Ù† (Ù…Ø³ØªØ·ÙŠÙ„)', targetId: 'target-arm-r' },
            'leg-l': { type: 'rectangle-leg', color: '#6366f1', label: 'Ø§Ù„Ø³Ø§Ù‚ Ø§Ù„ÙŠØ³Ø±Ù‰ (Ù…Ø³ØªØ·ÙŠÙ„)', targetId: 'target-leg-l' },
            'leg-r': { type: 'rectangle-leg', color: '#6366f1', label: 'Ø§Ù„Ø³Ø§Ù‚ Ø§Ù„ÙŠÙ…Ù†Ù‰ (Ù…Ø³ØªØ·ÙŠÙ„)', targetId: 'target-leg-r' },
            'foot-l': { type: 'rectangle-foot', color: '#ef4444', label: 'Ø§Ù„Ù‚Ø¯Ù… Ø§Ù„ÙŠØ³Ø±Ù‰ (Ù…Ø³ØªØ·ÙŠÙ„)', targetId: 'target-foot-l' },
            'foot-r': { type: 'rectangle-foot', color: '#ef4444', label: 'Ø§Ù„Ù‚Ø¯Ù… Ø§Ù„ÙŠÙ…Ù†Ù‰ (Ù…Ø³ØªØ·ÙŠÙ„)', targetId: 'target-foot-r' },
        };
        
        const PART_KEYS = Object.keys(SHAPES_DATA);
        const TOTAL_PARTS = PART_KEYS.length;

        let gameState = {
            step: 0, // 0: Start, 1: Quiz & Assembly, 2: Complete
            assembledCount: 0,
            parts: {}, // To store dimensions, status, and whether it's unlocked
            score: 0,
            currentQuestionIndex: 0, 
            questions: []
        };
        
        let draggedElement = null;
        let isAudioInitialized = false; // Ù„ØªØªØ¨Ø¹ Ø­Ø§Ù„Ø© ØªÙ‡ÙŠØ¦Ø© Ø§Ù„ØµÙˆØª

        // --- Tone.js Sound Setup ---
        
        // Ø³ÙŠÙ†Ø«Ø³Ø§ÙŠØ²Ø± Ø¨Ø³ÙŠØ· Ù„Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„ØµØ­ÙŠØ­Ø© (ØµÙˆØª Ø±Ù†ÙŠÙ†/ØµÙÙŠØ±)
        const correctSynth = new Tone.MembraneSynth({
            "envelope" : {
                "attack" : 0.005,
                "decay" : 0.2,
                "sustain" : 0.0,
            },
            "octaves" : 10,
            "pitchDecay" : 0.01
        }).toDestination();
        
        // Ø³ÙŠÙ†Ø«Ø³Ø§ÙŠØ²Ø± Ù„Ù„Ø£ØµÙˆØ§Øª Ø§Ù„Ø§Ø­ØªÙØ§Ù„ÙŠØ© (Ø§Ù„ÙÙˆØ² Ø¨Ø§Ù„Ù„Ø¹Ø¨Ø©)
        const winSynth = new Tone.PolySynth(Tone.Synth, {
            oscillator: { type: "square" },
            envelope: {
                attack: 0.02,
                decay: 0.1,
                sustain: 0.0,
            }
        }).toDestination();

        /**
         * ÙŠØ¨Ø¯Ø£ Ø³ÙŠØ§Ù‚ Ø§Ù„ØµÙˆØª Ø¹Ù†Ø¯ Ø£ÙˆÙ„ ØªÙØ§Ø¹Ù„ Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù… (Ù…Ù‡Ù… Ù„Ù„Ù…ØªØµÙØ­Ø§Øª Ø§Ù„Ø­Ø¯ÙŠØ«Ø©).
         */
        function startAudioContext() {
            if (!isAudioInitialized) {
                Tone.start();
                isAudioInitialized = true;
                // Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ù…Ø³ØªÙ…Ø¹ Ø¨Ø¹Ø¯ Ø§Ù„ØªÙØ¹ÙŠÙ„
                document.body.removeEventListener('click', startAudioContext);
                document.body.onclick = null;
            }
        }
        
        /**
         * ÙŠØ´ØºÙ„ ØµÙˆØª Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„ØµØ­ÙŠØ­Ø© (Ù…ÙƒØ§ÙØ¦ Ù„Ù€ correct.mp3).
         */
        function playCorrectSound() {
            if (isAudioInitialized) {
                correctSynth.triggerAttackRelease("C5", "8n");
                correctSynth.triggerAttackRelease("E5", "8n", "+0.05");
                correctSynth.triggerAttackRelease("G5", "8n", "+0.1");
            }
        }

        /**
         * ÙŠØ´ØºÙ„ ØµÙˆØª Ø§Ù„ÙÙˆØ² Ø¨Ø§Ù„Ù„Ø¹Ø¨Ø© (Ù…ÙƒØ§ÙØ¦ Ù„Ù€ win.wav).
         */
        function playWinSound() {
            if (isAudioInitialized) {
                // ØªØªØ§Ø¨Ø¹ Ù†ØºÙ…Ø§Øª Ø§Ø­ØªÙØ§Ù„ÙŠØ© (C-E-G-C)
                winSynth.triggerAttackRelease(["C5", "E5", "G5"], "4n");
                winSynth.triggerAttackRelease("C6", "2n", Tone.now() + 0.5);
            }
        }

        // --- Core Functions ---

        /**
         * Generates random dimensions for the parts.
         */
        const generateDimensions = () => {
            // Generates dimensions for all 8 parts
            // *** ØªÙ… Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ Ù‡Ù†Ø§: Ù„Ø²ÙŠØ§Ø¯Ø© Ø§Ù„ØªØ­Ø¯ÙŠ ÙÙŠ Ø§Ù„Ø¶Ø±Ø¨ (Ù„Ø¬Ø¹Ù„Ù‡Ø§ Ø¶Ø±Ø¨ Ø¹Ø¯Ø¯ÙŠÙ† Ø£ÙƒØ¨Ø±) ***
            const bodyL = Math.floor(Math.random() * 10) + 10; // Ø§Ù„Ø·ÙˆÙ„: 10-19 ÙˆØ­Ø¯Ø© (Ø±Ù‚Ù…ÙŠÙ†)
            const bodyW = Math.floor(Math.random() * 5) + 10; // Ø§Ù„Ø¹Ø±Ø¶: 10-14 ÙˆØ­Ø¯Ø© (Ø±Ù‚Ù…ÙŠÙ†)
            // ******************************************************************

            const headS = Math.floor(Math.random() * 5) + 6; // 6-10
            const armL = Math.floor(Math.random() * 3) + 7; // 7-9
            const armW = Math.floor(Math.random() * 2) + 2; // 2-3
            const legL = Math.floor(Math.random() * 4) + 10; // 10-13
            const legW = Math.floor(Math.random() * 2) + 3;  // 3-4
            const footL = Math.floor(Math.random() * 3) + 5; // 5-7
            const footW = Math.floor(Math.random() * 2) + 8; // 8-9

            gameState.parts = {
                'head': { s: headS, assembled: false, unlocked: false, color: SHAPES_DATA['head'].color, correct: false },
                'body': { l: bodyL, w: bodyW, assembled: false, unlocked: false, color: SHAPES_DATA['body'].color, correct: false },
                'arm-l': { l: armL, w: armW, assembled: false, unlocked: false, color: SHAPES_DATA['arm-l'].color, correct: false },
                'arm-r': { l: armL, w: armW, assembled: false, unlocked: false, color: SHAPES_DATA['arm-r'].color, correct: false },
                'leg-l': { l: legL, w: legW, assembled: false, unlocked: false, color: SHAPES_DATA['leg-l'].color, correct: false },
                'leg-r': { l: legL, w: legW, assembled: false, unlocked: false, color: SHAPES_DATA['leg-r'].color, correct: false },
                'foot-l': { l: footL, w: footW, assembled: false, unlocked: false, color: SHAPES_DATA['foot-l'].color, correct: false },
                'foot-r': { l: footL, w: footW, assembled: false, unlocked: false, color: SHAPES_DATA['foot-r'].color, correct: false },
            };
        };

        /**
         * Generates the calculation challenges for all 8 parts.
         */
        const generateQuestions = () => {
            const P = gameState.parts;
            
            gameState.questions = [
                // 1. Head (Square - Perimeter)
                { partKey: 'head', metric: 'Ù…Ø­ÙŠØ· Ø§Ù„Ù…Ø±Ø¨Ø¹', shape: 'Ù…Ø±Ø¨Ø¹', formula: 'Ø§Ù„Ù…Ø­ÙŠØ· = Ø·ÙˆÙ„ Ø§Ù„Ø¶Ù„Ø¹ Ã— Ù¤', dimensions: `Ø·ÙˆÙ„ Ø§Ù„Ø¶Ù„Ø¹: ${P['head'].s} ÙˆØ­Ø¯Ø©`, correctAnswer: P['head'].s * 4, maxScore: 5 },
                // 2. Body (Rectangle - Area) - Ø§Ù„ØªØ­Ø¯ÙŠ Ø§Ù„Ø£ÙƒØ¨Ø± Ù„Ù„Ø¶Ø±Ø¨ ÙÙŠ Ø¹Ø¯Ø¯ÙŠÙ†
                { partKey: 'body', metric: 'Ù…Ø³Ø§Ø­Ø© Ø§Ù„Ù…Ø³ØªØ·ÙŠÙ„', shape: 'Ù…Ø³ØªØ·ÙŠÙ„', formula: 'Ø§Ù„Ù…Ø³Ø§Ø­Ø© = Ø§Ù„Ø·ÙˆÙ„ Ã— Ø§Ù„Ø¹Ø±Ø¶', dimensions: `Ø§Ù„Ø·ÙˆÙ„: ${P['body'].l} ÙˆØ­Ø¯Ø©ØŒ Ø§Ù„Ø¹Ø±Ø¶: ${P['body'].w} ÙˆØ­Ø¯Ø©`, correctAnswer: P['body'].l * P['body'].w, maxScore: 5 },
                // 3. Arm Left (Rectangle Small - Area)
                { partKey: 'arm-l', metric: 'Ù…Ø³Ø§Ø­Ø© Ø§Ù„Ù…Ø³ØªØ·ÙŠÙ„', shape: 'Ù…Ø³ØªØ·ÙŠÙ„', formula: 'Ø§Ù„Ù…Ø³Ø§Ø­Ø© = Ø§Ù„Ø·ÙˆÙ„ Ã— Ø§Ù„Ø¹Ø±Ø¶', dimensions: `Ø§Ù„Ø·ÙˆÙ„: ${P['arm-l'].l} ÙˆØ­Ø¯Ø©ØŒ Ø§Ù„Ø¹Ø±Ø¶: ${P['arm-l'].w} ÙˆØ­Ø¯Ø©`, correctAnswer: P['arm-l'].l * P['arm-l'].w, maxScore: 5 },
                // 4. Arm Right (Rectangle Small - Perimeter)
                { partKey: 'arm-r', metric: 'Ù…Ø­ÙŠØ· Ø§Ù„Ù…Ø³ØªØ·ÙŠÙ„', shape: 'Ù…Ø³ØªØ·ÙŠÙ„', formula: 'Ø§Ù„Ù…Ø­ÙŠØ· = Ù¢ Ã— (Ø§Ù„Ø·ÙˆÙ„ + Ø§Ù„Ø¹Ø±Ø¶)', dimensions: `Ø§Ù„Ø·ÙˆÙ„: ${P['arm-r'].l} ÙˆØ­Ø¯Ø©ØŒ Ø§Ù„Ø¹Ø±Ø¶: ${P['arm-r'].w} ÙˆØ­Ø¯Ø©`, correctAnswer: 2 * (P['arm-r'].l + P['arm-r'].w), maxScore: 5 },
                // 5. Leg Left (Rectangle Leg - Perimeter)
                { partKey: 'leg-l', metric: 'Ù…Ø­ÙŠØ· Ø§Ù„Ù…Ø³ØªØ·ÙŠÙ„', shape: 'Ù…Ø³ØªØ·ÙŠÙ„', formula: 'Ø§Ù„Ù…Ø­ÙŠØ· = Ù¢ Ã— (Ø§Ù„Ø·ÙˆÙ„ + Ø§Ù„Ø¹Ø±Ø¶)', dimensions: `Ø§Ù„Ø·ÙˆÙ„: ${P['leg-l'].l} ÙˆØ­Ø¯Ø©ØŒ Ø§Ù„Ø¹Ø±Ø¶: ${P['leg-l'].w} ÙˆØ­Ø¯Ø©`, correctAnswer: 2 * (P['leg-l'].l + P['leg-l'].w), maxScore: 5 },
                // 6. Leg Right (Rectangle Leg - Area)
                { partKey: 'leg-r', metric: 'Ù…Ø³Ø§Ø­Ø© Ø§Ù„Ù…Ø³ØªØ·ÙŠÙ„', shape: 'Ù…Ø³ØªØ·ÙŠÙ„', formula: 'Ø§Ù„Ù…Ø³Ø§Ø­Ø© = Ø§Ù„Ø·ÙˆÙ„ Ã— Ø§Ù„Ø¹Ø±Ø¶', dimensions: `Ø§Ù„Ø·ÙˆÙ„: ${P['leg-r'].l} ÙˆØ­Ø¯Ø©ØŒ Ø§Ù„Ø¹Ø±Ø¶: ${P['leg-r'].w} ÙˆØ­Ø¯Ø©`, correctAnswer: P['leg-r'].l * P['leg-r'].w, maxScore: 5 },
                // 7. Foot Left (Rectangle Foot - Area)
                { partKey: 'foot-l', metric: 'Ù…Ø³Ø§Ø­Ø© Ø§Ù„Ù…Ø³ØªØ·ÙŠÙ„', shape: 'Ù…Ø³ØªØ·ÙŠÙ„', formula: 'Ø§Ù„Ù…Ø³Ø§Ø­Ø© = Ø§Ù„Ø·ÙˆÙ„ Ã— Ø§Ù„Ø¹Ø±Ø¶', dimensions: `Ø§Ù„Ø·ÙˆÙ„: ${P['foot-l'].l} ÙˆØ­Ø¯Ø©ØŒ Ø§Ù„Ø¹Ø±Ø¶: ${P['foot-l'].w} ÙˆØ­Ø¯Ø©`, correctAnswer: P['foot-l'].l * P['foot-l'].w, maxScore: 5 },
                // 8. Foot Right (Rectangle Foot - Perimeter)
                { partKey: 'foot-r', metric: 'Ù…Ø­ÙŠØ· Ø§Ù„Ù…Ø³ØªØ·ÙŠÙ„', shape: 'Ù…Ø³ØªØ·ÙŠÙ„', formula: 'Ø§Ù„Ù…Ø­ÙŠØ· = Ù¢ Ã— (Ø§Ù„Ø·ÙˆÙ„ + Ø§Ù„Ø¹Ø±Ø¶)', dimensions: `Ø§Ù„Ø·ÙˆÙ„: ${P['foot-r'].l} ÙˆØ­Ø¯Ø©ØŒ Ø§Ù„Ø¹Ø±Ø¶: ${P['foot-r'].w} ÙˆØ­Ø¯Ø©`, correctAnswer: 2 * (P['foot-r'].l + P['foot-r'].w), maxScore: 5 },
            ];
            gameState.currentQuestionIndex = 0; // Start with the first question
        }

        // --- Drag and Drop Handlers ---
        
        window.dragStart = (e) => {
            const draggableEl = e.currentTarget;
            const partKey = draggableEl.dataset.part;

            // Only allow dragging if the part is unlocked
            if (gameState.parts[partKey] && gameState.parts[partKey].unlocked && !gameState.parts[partKey].assembled) {
                draggedElement = draggableEl; 
                e.dataTransfer.setData('text/plain', partKey);
                e.dataTransfer.effectAllowed = 'move';
                draggableEl.classList.add('opacity-50', 'ring-4', 'ring-indigo-400');
            } else {
                 e.preventDefault(); // Prevent dragging if locked
                 // Optional: Add a visual feedback for locked status
                 draggableEl.classList.add('ring-4', 'ring-red-500');
                 setTimeout(() => draggableEl.classList.remove('ring-4', 'ring-red-500'), 500);
            }
        };

        window.dragEnd = (e) => {
            if (draggedElement) {
                draggedElement.classList.remove('opacity-50', 'ring-4', 'ring-indigo-400');
                draggedElement = null; 
            }
        };

        window.dragOver = (e) => {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            e.currentTarget.classList.add('drag-over');
        };

        window.dragLeave = (e) => {
            e.currentTarget.classList.remove('drag-over');
        };

        window.dropItem = (e, targetKey) => {
            e.preventDefault();
            e.currentTarget.classList.remove('drag-over');

            const partKey = e.dataTransfer.getData('text/plain');
            const targetId = e.currentTarget.id;

            // Check if the dragged part matches the target area AND is unlocked
            if (SHAPES_DATA[partKey] && SHAPES_DATA[partKey].targetId === targetId && gameState.parts[partKey].unlocked && !gameState.parts[partKey].assembled) {
                
                // 1. Mark as assembled
                gameState.parts[partKey].assembled = true;
                gameState.assembledCount++;

                // 2. Hide the draggable shape and remove unlocked class
                const draggableEl = document.getElementById(`shape-drag-${partKey}`);
                if (draggableEl) {
                    draggableEl.classList.add('hidden');
                    draggableEl.classList.remove('unlocked');
                }

                // 3. Style the target area to show the assembled part
                const targetEl = e.currentTarget;
                targetEl.classList.add('assembled');
                targetEl.style.backgroundColor = gameState.parts[partKey].color;
                targetEl.style.borderColor = gameState.parts[partKey].color;
                targetEl.style.borderWidth = '4px';

                // 4. Move to the next question/part challenge
                if (gameState.assembledCount < TOTAL_PARTS) {
                    gameState.currentQuestionIndex = gameState.assembledCount; // Next question index is the current assembly count
                } else {
                    gameState.step = 2; // All parts assembled and calculated
                    playWinSound(); // *** ØªØ´ØºÙŠÙ„ ØµÙˆØª Ø§Ù„ÙÙˆØ² ***
                }
                
                updateUI();
            } else if (gameState.parts[partKey].assembled) {
                 // Do nothing if already assembled
            } else {
                // Wrong target feedback
                e.currentTarget.classList.add('ring-4', 'ring-red-500');
                setTimeout(() => e.currentTarget.classList.remove('ring-4', 'ring-red-500'), 500);
            }
        };

        // --- Calculation Logic ---

        /**
         * Logic to submit the answer for the current question.
         */
        window.submitAnswer = () => {
            if (gameState.assembledCount >= TOTAL_PARTS) return; // Should not happen

            const question = gameState.questions[gameState.currentQuestionIndex];
            const inputField = document.getElementById('calculation-input');
            const feedbackEl = document.getElementById('calculation-feedback');
            
            // We use Math.round and compare to handle any floating point inaccuracies if any are introduced later.
            const userAnswer = parseInt(inputField.value.trim(), 10);
            
            if (isNaN(userAnswer)) {
                feedbackEl.textContent = 'Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ Ù‚ÙŠÙ…Ø© Ø±Ù‚Ù…ÙŠØ© ØµØ­ÙŠØ­Ø©.';
                feedbackEl.classList.remove('text-green-600', 'text-indigo-600');
                feedbackEl.classList.add('text-red-600');
                inputField.focus();
                return;
            }
            
            // Check if the integer part of the user answer matches the correct answer
            if (userAnswer === Math.round(question.correctAnswer)) {
                
                playCorrectSound(); // *** ØªØ´ØºÙŠÙ„ ØµÙˆØª Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„ØµØ­ÙŠØ­Ø© ***

                // Correct Answer: Unlock the part!
                gameState.score += question.maxScore;
                gameState.parts[question.partKey].correct = true;
                gameState.parts[question.partKey].unlocked = true;

                // Visual Feedback
                feedbackEl.textContent = `ğŸ‰ Ø£Ø­Ø³Ù†Øª! Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© ØµØ­ÙŠØ­Ø©. ØªÙ… ØªØ­Ø±ÙŠØ± Ø¬Ø²Ø¡ "${SHAPES_DATA[question.partKey].label}"!`;
                feedbackEl.classList.remove('text-red-600', 'text-indigo-600');
                feedbackEl.classList.add('text-green-600', 'font-bold');

                // Disable input and button
                inputField.disabled = true;
                document.getElementById('submit-btn').classList.add('hidden');

                // Show assembly instruction
                document.getElementById('assembly-instruction').classList.remove('hidden');
                document.getElementById('assembly-instruction').textContent = `Ø§Ù„Ø¢Ù†ØŒ Ø§Ø³Ø­Ø¨ Ø¬Ø²Ø¡ ${SHAPES_DATA[question.partKey].label.split('(')[0].trim()} Ø¥Ù„Ù‰ Ù…ÙƒØ§Ù†Ù‡ ÙÙŠ Ø§Ù„Ø±ÙˆØ¨ÙˆØª.`;

                // Add pulse to the unlocked shape
                const shapeEl = document.getElementById(`shape-drag-${question.partKey}`);
                if (shapeEl) {
                    shapeEl.classList.add('unlocked', 'correct-pulse');
                }

                // Add pulse to the target area
                 const targetEl = document.getElementById(SHAPES_DATA[question.partKey].targetId);
                 if(targetEl) {
                     targetEl.classList.add('correct-pulse');
                 }


            } else {
                // Wrong Answer
                gameState.score = Math.max(0, gameState.score - 1); 
                feedbackEl.textContent = `âŒ Ø¥Ø¬Ø§Ø¨Ø© Ø®Ø§Ø·Ø¦Ø©. Ø­Ø§ÙˆÙ„ Ù…Ø¬Ø¯Ø¯Ø§Ù‹! (Ø®Ø³Ø±Øª Ù†Ù‚Ø·Ø©)`;
                feedbackEl.classList.remove('text-green-600', 'text-indigo-600');
                feedbackEl.classList.add('text-red-600');
                // Re-enable the submit button in case it was hidden accidentally
                document.getElementById('submit-btn').classList.remove('hidden');
            }
            updateUI(); // Re-render to update score and shape status
        }
        
        // --- UI Rendering ---

        const renderStep1QuizAndAssembly = () => {
            const container = document.getElementById('game-content');
            const question = gameState.questions[gameState.currentQuestionIndex];
            const partToUnlock = SHAPES_DATA[question.partKey];
            const partData = gameState.parts[question.partKey];

            // 1. Draggable Shapes (Toolbox)
            const draggableShapes = PART_KEYS.map(key => {
                const data = SHAPES_DATA[key];
                const part = gameState.parts[key];
                
                if (part.assembled) return ''; // Hide if assembled
                
                let shapeClass = '';
                if (data.type === 'rectangle') shapeClass = 'shape-rect-lg';
                if (data.type === 'square') shapeClass = 'shape-square';
                if (data.type === 'rectangle-small') shapeClass = 'shape-rect-arm';
                if (data.type === 'rectangle-leg') shapeClass = 'shape-rect-leg';
                if (data.type === 'rectangle-foot') shapeClass = 'shape-rect-foot';

                // Add 'unlocked' class if the part has been successfully calculated
                const unlockedClass = part.unlocked ? 'unlocked' : 'bg-gray-400';
                
                const labelText = data.label.split('(')[0].trim(); // Get only the name

                return `
                    <div id="shape-drag-${key}" data-part="${key}" draggable="true" 
                         ondragstart="dragStart(event)" ondragend="dragEnd(event)"
                         class="shape-draggable ${shapeClass} bg-indigo-500 hover:bg-indigo-600 text-white flex items-center justify-center font-bold rounded-lg shadow-md transition-all ${unlockedClass}">
                        ${labelText}
                    </div>
                `;
            }).join('');

            // 2. Robot Assembly Area (Targets)
            const robotTargets = PART_KEYS.map(key => {
                const data = SHAPES_DATA[key];
                const part = gameState.parts[key];

                let shapeClass = '';
                if (data.type === 'rectangle') shapeClass = 'shape-rect-lg';
                if (data.type === 'square') shapeClass = 'shape-square';
                if (data.type === 'rectangle-small') shapeClass = 'shape-rect-arm';
                if (data.type === 'rectangle-leg') shapeClass = 'shape-rect-leg';
                if (data.type === 'rectangle-foot') shapeClass = 'shape-rect-foot';

                const assembledClass = part.assembled ? 'assembled' : '';
                const styleAttr = part.assembled ? `style="background-color: ${part.color}; border-color: ${part.color}; border-width: 4px;"` : '';

                return `
                     <div id="${data.targetId}" data-part-target="${key}" 
                         ondragover="dragOver(event)" ondragleave="dragLeave(event)" ondrop="dropItem(event, '${key}')"
                         class="robot-part ${shapeClass} flex items-center justify-center ${assembledClass}" ${styleAttr}>
                         ${data.label.split('(')[0].trim()}
                    </div>
                `;
            }).join('');

            // 3. Calculation Card
            const calculationCard = `
                <div class="question-card lg:w-full">
                    <h3 class="text-2xl font-black text-blue-700 mb-4">
                        ğŸ’¡ ØªØ­Ø¯ÙŠ Ø§Ù„Ù‚ÙŠØ§Ø³ ${gameState.currentQuestionIndex + 1} Ù…Ù† ${TOTAL_PARTS}
                    </h3>
                    <p class="text-lg text-gray-700 mb-2">
                        **Ø¬Ø²Ø¡ Ø§Ù„Ø±ÙˆØ¨ÙˆØª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨ ØªØ­Ø±ÙŠØ±Ù‡:** <span class="font-bold text-red-600">${partToUnlock.label.split('(')[0].trim()}</span>
                    </p>
                    <p class="text-md text-gray-600 mb-4">
                        **Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯:** <span class="font-mono text-lg text-red-600">${question.dimensions}</span>
                    </p>

                    <!-- APPLYING THE NEW FONT CLASS HERE: font-serif-math -->
                    <div class="bg-blue-50 p-4 rounded-lg mb-6 border-l-4 border-blue-500 font-serif-math">
                        <p class="font-bold text-xl text-blue-800 mb-2">Ø§Ù„Ù…Ø·Ù„ÙˆØ¨:</p>
                        <!-- text-lg for formula font size, removed font-mono class -->
                        <p class="text-lg text-blue-900">Ø§Ø­Ø³Ø¨ **${question.metric}** Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù‚Ø§Ù†ÙˆÙ†:
                             <span class="font-bold">
                             ${question.shape === 'Ù…Ø±Ø¨Ø¹' 
                                 ? (question.metric.includes('Ù…Ø³Ø§Ø­Ø©') 
                                    ? 'Ø§Ù„Ù…Ø³Ø§Ø­Ø© = Ø·ÙˆÙ„ Ø§Ù„Ø¶Ù„Ø¹ Ã— Ø·ÙˆÙ„ Ø§Ù„Ø¶Ù„Ø¹' 
                                    : 'Ø§Ù„Ù…Ø­ÙŠØ· = Ø·ÙˆÙ„ Ø§Ù„Ø¶Ù„Ø¹ Ã— Ù¤')
                                 : (question.metric.includes('Ù…Ø³Ø§Ø­Ø©') 
                                    ? 'Ø§Ù„Ù…Ø³Ø§Ø­Ø© = Ø§Ù„Ø·ÙˆÙ„ Ã— Ø§Ù„Ø¹Ø±Ø¶' 
                                    : 'Ø§Ù„Ù…Ø­ÙŠØ· = Ù¢ Ã— (Ø§Ù„Ø·ÙˆÙ„ + Ø§Ù„Ø¹Ø±Ø¶)')
                             }
                             </span>
                        </p>
                    </div>

                    <label for="calculation-input" class="block text-lg font-medium text-gray-800 mb-2">
                        Ù…Ø§ Ù‡ÙŠ Ù‚ÙŠÙ…Ø© ${question.metric}ØŸ (Ø£Ø¯Ø®Ù„ Ø±Ù‚Ù…Ø§Ù‹ ØµØ­ÙŠØ­Ø§Ù‹)
                    </label>
                    <input type="number" id="calculation-input" min="1" class="w-full p-3 border-2 border-gray-300 rounded-lg text-2xl text-center focus:border-indigo-500 focus:ring-indigo-500 transition" placeholder="Ø£Ø¯Ø®Ù„ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ù‡Ù†Ø§..." ${partData.unlocked ? 'disabled' : ''}/>
                    
                    <div class="mt-6">
                        <button onclick="submitAnswer()" id="submit-btn" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 rounded-lg transition duration-150 shadow-md ${partData.unlocked ? 'hidden' : ''}">
                            ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© ÙˆØ§Ù„ØªØ­Ø±ÙŠØ±
                        </button>
                    </div>
                    
                    <p id="calculation-feedback" class="mt-4 text-center h-6 font-medium text-indigo-600"></p>
                     <p id="assembly-instruction" class="mt-4 text-center text-lg font-black text-purple-700 p-2 border-dashed border-2 border-purple-300 rounded-lg ${!partData.unlocked ? 'hidden' : ''}">
                         Ø§Ù„Ø¢Ù†ØŒ Ø§Ø³Ø­Ø¨ Ø¬Ø²Ø¡ ${partToUnlock.label.split('(')[0].trim()} Ø¥Ù„Ù‰ Ù…ÙƒØ§Ù†Ù‡ ÙÙŠ Ø§Ù„Ø±ÙˆØ¨ÙˆØª.
                    </p>
                </div>
            `;


            container.innerHTML = `
                <div class="flex flex-col lg:flex-row gap-8">
                    <!-- Toolbox and Quiz -->
                    <div class="lg:w-1/2 space-y-8">
                        <!-- Calculation Challenge Card -->
                        ${calculationCard}

                        <!-- Toolbox (Draggable Shapes) -->
                        <div class="p-6 bg-white rounded-xl shadow-lg border-r-4 border-indigo-500">
                            <h3 class="text-xl font-bold text-gray-800 mb-4">âš™ï¸ ØµÙ†Ø¯ÙˆÙ‚ Ø§Ù„Ø£Ø¯ÙˆØ§Øª (Ø§Ù„Ø£Ø¬Ø²Ø§Ø¡ Ø§Ù„Ù…Ù‚ÙÙ„Ø©/Ø§Ù„Ù…Ø­Ø±Ø±Ø©)</h3>
                            <div class="flex flex-wrap gap-4 shape-container">
                                ${draggableShapes}
                            </div>
                        </div>
                    </div>

                    <!-- Robot Assembly Area (Targets) -->
                    <div class="lg:w-1/2 p-6 bg-gray-100 rounded-xl shadow-inner flex items-center justify-center">
                        <div id="robot-assembly">
                            ${robotTargets}
                            <!-- Assembly Count -->
                            <div class="absolute bottom-4 left-1/2 transform -translate-x-1/2 text-lg font-bold text-gray-700">
                                ØªÙ… ØªØ¬Ù…ÙŠØ¹: ${gameState.assembledCount} Ù…Ù† ${TOTAL_PARTS}
                            </div>
                        </div>
                    </div>
                </div>
            `;
        };
        
        const renderStep2Complete = () => {
            const container = document.getElementById('game-content');
            const finalScore = gameState.score;
            
            container.innerHTML = `
                <div class="text-center p-10 bg-green-100 rounded-xl shadow-2xl">
                    <span class="text-8xl">ğŸ¤–ğŸ‰</span>
                    <h2 class="text-4xl font-black text-green-700 mt-4 mb-2">Ù…Ù‡Ù…Ø© Ø§Ù„Ø¨Ù†Ø§Ø¡ ÙˆØ§Ù„Ù‚ÙŠØ§Ø³ Ø§ÙƒØªÙ…Ù„Øª Ø¨Ù†Ø¬Ø§Ø­!</h2>
                    <p class="text-xl text-gray-700">Ù„Ù‚Ø¯ Ù†Ø¬Ø­Øª ÙÙŠ ØªØ­Ø¯ÙŠ 8 Ù…Ø³Ø§Ø¦Ù„ Ø±ÙŠØ§Ø¶ÙŠØ© ÙˆØªØ¬Ù…ÙŠØ¹ Ø§Ù„Ø±ÙˆØ¨ÙˆØª Ø¨Ø§Ù„ÙƒØ§Ù…Ù„.</p>
                    <p class="text-3xl font-extrabold text-indigo-600 mt-4">Ù†Ù‚Ø§Ø·Ùƒ Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠØ©: ${finalScore}</p>
                    
                    <button onclick="initializeGame()" class="mt-8 bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-3 px-6 rounded-full text-lg shadow-lg transition transform hover:scale-105">
                        Ø¨Ù†Ø§Ø¡ Ø±ÙˆØ¨ÙˆØª Ø¬Ø¯ÙŠØ¯ (ØªØ­Ø¯ÙŠ Ø¬Ø¯ÙŠØ¯)
                    </button>
                </div>
            `;
        };
        
        // Helper function to get the current step name in Arabic
        const getCurrentStepName = () => {
            if (gameState.step === 2) return 'Ø§Ù„Ø§Ù†ØªÙ‡Ø§Ø¡';
            if (gameState.assembledCount === TOTAL_PARTS) return 'Ø§Ù„ØªØ¬Ù…ÙŠØ¹ Ø§ÙƒØªÙ…Ù„';
            return `ØªØ­Ø¯ÙŠ Ø§Ù„Ø¬Ø²Ø¡ ${gameState.assembledCount + 1} Ù…Ù† 8`;
        }

        /**
         * Main UI update function.
         */
        window.updateUI = () => {
            // Update the score display
            const scoreElement = document.getElementById('score-value');
            if (scoreElement) {
                scoreElement.textContent = gameState.score;
            }

            // Update the step name display
            const stepElement = document.getElementById('step-name');
            if (stepElement) {
                stepElement.textContent = getCurrentStepName();
            }

            // Render the main content based on the step
            if (gameState.assembledCount < TOTAL_PARTS) {
                renderStep1QuizAndAssembly();
            } else {
                 renderStep2Complete();
            }
        };
        
        /**
         * Resets and starts the game.
         */
        window.initializeGame = () => {
            // Reset state
            gameState = {
                step: 1, 
                assembledCount: 0,
                parts: {},
                score: 0,
                currentQuestionIndex: 0, 
                questions: []
            };
            
            // Generate new data
            generateDimensions();
            generateQuestions();
            
            // Render UI
            updateUI();
        }

        // --- Initialization ---
        window.onload = initializeGame;
    </script>

    <div class="max-w-7xl mx-auto space-y-8">
        <header class="text-center bg-white p-6 rounded-xl shadow-lg border-b-4 border-blue-500">
            <h1 class="text-4xl font-black text-gray-900">
                Ù…ØµÙ†Ø¹ Ø§Ù„Ø±ÙˆØ¨ÙˆØª: ØªØ­Ø¯ÙŠ Ø§Ù„Ù‚ÙŠØ§Ø³ ÙˆØ§Ù„ØªØ¬Ù…ÙŠØ¹ Ø§Ù„Ù…ØªØ³Ù„Ø³Ù„
            </h1>
            <p class="mt-2 text-gray-600">
                Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©: <span id="step-name" class="font-bold text-red-500">ØªØ­Ø¯ÙŠ Ø§Ù„Ù‚ÙŠØ§Ø³...</span>
                 | <span class="font-bold text-indigo-500">Ø§Ù„Ù†Ù‚Ø§Ø·: </span><span id="score-value" class="font-bold text-indigo-500">0</span>
            </p>
        </header>

        <!-- Game Content Container -->
        <div id="game-content" class="bg-white p-8 rounded-xl shadow-2xl min-h-[700px]">
            <!-- Content will be injected here by JavaScript based on the current step -->
        </div>

    </div>

</body>
</html>